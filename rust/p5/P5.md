# PROJECT SPECIFICATION

## API Gateway with Key-Based Authentication

**Project Code:** RUST-SEC-005  
**Duration:** 3-4 days  
**Team:** Platform Services - Identity & Access Management  
**Stakeholder:** API Platform Team & Developer Relations

-----

## EXECUTIVE SUMMARY

Our microservices architecture requires a secure API gateway that validates client requests before routing to backend services. This proof-of-concept will demonstrate API key authentication patterns that align with industry standards and can inform our production gateway design.

## PROJECT OBJECTIVES

Build an HTTP server that acts as an API gateway, authenticating clients via API keys passed in request headers and providing access to protected endpoints. This simulates real-world identity and access management scenarios you’ll encounter in the Entra ID team.

## BUSINESS CONTEXT

**Current Situation:**

- Multiple internal services need authentication
- No standardized authentication mechanism across services
- Developer onboarding slowed by inconsistent API access patterns

**Solution:**

- Centralized authentication gateway
- Standard API key format and validation
- Clear documentation for service consumers

**Success Criteria:**

- Reduce unauthorized access attempts by 90%
- Standardize authentication across 20+ internal APIs
- Improve developer experience with clear auth patterns

## FUNCTIONAL REQUIREMENTS

### Must Have (P0)

#### Core Gateway Features

- **FR-1:** HTTP server listens on configurable port (default: 8080)
- **FR-2:** Accept API keys via `Authorization` header (`Authorization: Bearer <api-key>`)
- **FR-3:** Validate API keys against in-memory store
- **FR-4:** Return 401 Unauthorized for missing/invalid keys
- **FR-5:** Return 200 OK for valid authenticated requests

#### Endpoints

- **FR-6:** `GET /health` - Public health check (no auth required)
- **FR-7:** `GET /api/protected` - Protected endpoint (requires valid API key)
- **FR-8:** `POST /api/admin/keys` - Generate new API key (requires admin key)
- **FR-9:** `DELETE /api/admin/keys/{key}` - Revoke API key (requires admin key)

#### Key Management

- **FR-10:** Generate cryptographically secure API keys
- **FR-11:** Store keys in memory with metadata (owner, created_at, permissions)
- **FR-12:** Support key revocation
- **FR-13:** Pre-configure at least one admin key on startup

### Should Have (P1)

- **FR-14:** Rate limiting per API key (e.g., 100 requests/hour)
- **FR-15:** Request logging with authentication status
- **FR-16:** Key expiration (time-to-live)
- **FR-17:** Scopes/permissions per key (read, write, admin)
- **FR-18:** `GET /api/admin/keys` - List all active keys (requires admin key)
- **FR-19:** Request metrics (total requests, auth failures, etc.)

### Nice to Have (P2)

- **FR-20:** Load keys from configuration file on startup
- **FR-21:** CORS support for browser-based clients
- **FR-22:** Multiple protected endpoints with different permission levels
- **FR-23:** API key usage statistics per key

## SECURITY REQUIREMENTS

⚠️ **CRITICAL SECURITY REQUIREMENTS**

- **SEC-1:** API keys must be cryptographically random (32+ bytes)
- **SEC-2:** Use constant-time comparison for API key validation
- **SEC-3:** Never log API keys in plaintext
- **SEC-4:** Admin endpoints require elevated permissions
- **SEC-5:** Rate limit authentication attempts to prevent brute force
- **SEC-6:** Return generic error messages (don’t leak existence of keys)

## TECHNICAL REQUIREMENTS

### Core Technology

- **Language:** Rust (latest stable version)
- **HTTP Server:** Choose one:
  - `tiny_http` (simple, std-library style)
  - `hyper` (more feature-rich)
  - `actix-web` (full-featured, recommended for P1)
  - `axum` (modern, ergonomic)

### Recommended Crates

- HTTP server library (see above)
- `rand` - secure random key generation
- `serde` & `serde_json` - JSON request/response handling
- `chrono` - timestamp handling (optional)

### API Key Format

Generate keys as hex-encoded random bytes:

```
Format: 64 hex characters (32 bytes)
Example: a1b2c3d4e5f6... (64 chars total)
```

### Data Structures

```rust
struct ApiKey {
    key: String,           // The actual key value
    owner: String,         // Key owner identifier
    created_at: DateTime,  // Creation timestamp
    expires_at: Option<DateTime>, // Optional expiration
    scopes: Vec<String>,   // Permissions ["read", "write", "admin"]
    request_count: u64,    // Usage tracking
}
```

## API SPECIFICATIONS

### Endpoint Definitions

#### 1. Health Check (Public)

```http
GET /health HTTP/1.1
Host: localhost:8080

Response: 200 OK
{
  "status": "healthy",
  "timestamp": "2025-12-23T10:45:00Z"
}
```

#### 2. Protected Resource

```http
GET /api/protected HTTP/1.1
Host: localhost:8080
Authorization: Bearer a1b2c3d4e5f6...

Response: 200 OK
{
  "message": "Access granted",
  "authenticated_as": "user@example.com"
}
```

#### 3. Generate New API Key (Admin)

```http
POST /api/admin/keys HTTP/1.1
Host: localhost:8080
Authorization: Bearer <admin-key>
Content-Type: application/json

{
  "owner": "service-a",
  "scopes": ["read", "write"],
  "expires_in_days": 90
}

Response: 201 Created
{
  "api_key": "a1b2c3d4e5f6...",
  "owner": "service-a",
  "created_at": "2025-12-23T10:45:00Z",
  "expires_at": "2026-03-23T10:45:00Z"
}
```

#### 4. Revoke API Key (Admin)

```http
DELETE /api/admin/keys/a1b2c3d4e5f6... HTTP/1.1
Host: localhost:8080
Authorization: Bearer <admin-key>

Response: 200 OK
{
  "message": "API key revoked successfully"
}
```

### Error Responses

```http
401 Unauthorized
{
  "error": "Unauthorized",
  "message": "Invalid or missing API key"
}

403 Forbidden
{
  "error": "Forbidden",
  "message": "Insufficient permissions"
}

429 Too Many Requests
{
  "error": "Rate Limit Exceeded",
  "message": "Too many requests. Try again later."
}
```

## ACCEPTANCE CRITERIA

1. ✅ Server starts and responds on configured port
1. ✅ Public endpoints accessible without authentication
1. ✅ Protected endpoints reject requests without valid API key
1. ✅ Admin can generate new API keys via API
1. ✅ Admin can revoke API keys via API
1. ✅ Rate limiting prevents brute force attacks (P1)
1. ✅ All security requirements met
1. ✅ Proper HTTP status codes returned
1. ✅ JSON responses are well-formed

## TESTING REQUIREMENTS

### Manual Testing with curl

```bash
# Test health endpoint (public)
curl http://localhost:8080/health

# Test protected endpoint without auth (should fail)
curl http://localhost:8080/api/protected

# Test protected endpoint with valid key (should succeed)
curl -H "Authorization: Bearer <key>" http://localhost:8080/api/protected

# Generate new API key
curl -X POST http://localhost:8080/api/admin/keys \
  -H "Authorization: Bearer <admin-key>" \
  -H "Content-Type: application/json" \
  -d '{"owner": "test-client", "scopes": ["read"]}'

# Revoke API key
curl -X DELETE http://localhost:8080/api/admin/keys/<key> \
  -H "Authorization: Bearer <admin-key>"
```

### Test Scenarios

1. Access public endpoint (should succeed)
1. Access protected endpoint without key (should return 401)
1. Access protected endpoint with invalid key (should return 401)
1. Access protected endpoint with valid key (should return 200)
1. Generate new key without admin rights (should return 403)
1. Generate new key with admin key (should return 201)
1. Use newly generated key to access protected endpoint
1. Revoke key and verify it no longer works
1. Test rate limiting by making many requests (P1)

## DELIVERABLES

1. Source code in a Git repository
1. README.md with:
- Architecture overview
- API documentation
- Setup and run instructions
- Testing examples
- Security considerations
1. Postman/Bruno collection or curl examples for all endpoints
1. Configuration documentation
1. Technical write-up explaining:
- Authentication flow
- Key generation strategy
- Security design decisions

## SUCCESS METRICS

- 100% authentication accuracy (no false positives/negatives)
- Response time < 50ms for authentication checks
- Can handle 100 concurrent requests
- Zero API keys logged in plaintext
- All endpoints properly secured

## LEARNING OBJECTIVES

By completing this project, you will understand:

- HTTP authentication patterns (Bearer tokens)
- API gateway architecture
- Request/response handling in Rust
- JSON serialization and deserialization
- Permission and scope-based access control
- Rate limiting strategies
- RESTful API design principles
- Security headers and CORS (P2)

## REAL-WORLD CONNECTIONS

This project directly relates to your Microsoft internship:

- **Entra ID** uses similar token-based authentication
- **Network access** involves validating credentials
- **Identity management** includes key generation and revocation
- **API security** is fundamental to cloud services

## STRETCH GOALS

If time permits:

- JWT token support (as alternative to API keys)
- Refresh token mechanism
- Role-based access control (RBAC)
- Audit logging (who accessed what, when)
- OpenAPI/Swagger documentation
- Docker containerization
- Integration tests with automated testing framework

-----

**Project Owner:** [Your Name]  
**Start Date:** TBD  
**Target Completion:** 3-4 days from start

**Security Review Required:** Yes  
**Load Testing Required:** Optional (P2)  
**Documentation Required:** Yes - API specs for consumers
